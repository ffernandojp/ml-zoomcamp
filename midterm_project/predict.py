# -*- coding: utf-8 -*-
"""predict_model_ml_zoomcamp.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BPHVJEM_eUHJyO45kCXf-LCSlD3IhFW-
"""

import pickle
import numpy as np
import pandas as pd
from flask import Flask, request, jsonify

# --- Configuration ---
MODEL_FILE = 'model.bin'
# These are the exact features your model expects, in the correct order 
# (excluding the 'quality' score that caused leakage)
FEATURES = [
    'fixed_acidity', 'volatile_acidity', 'citric_acid', 'residual_sugar',
    'chlorides', 'free_sulfur_dioxide', 'total_sulfur_dioxide',
    'density', 'ph', 'sulphates', 'alcohol'
]

# 1. Load the Model
with open(MODEL_FILE, 'rb') as f_in:
    model = pickle.load(f_in)

# 2. Initialize the Flask application
app = Flask('wine-quality-prediction')

def prepare_input(wine_data):
    """
    Ensures the input dictionary is converted into a DataFrame
    with the correct feature columns and order expected by the model.
    """
    # Create a DataFrame from the input data list
    df_input = pd.DataFrame(wine_data)

    # Ensure the DataFrame has the correct columns in the expected order
    # using the FEATURES list defined above
    df_input = df_input[FEATURES]

    return df_input

def predict(df_input):
    """Generates predictions and probabilities."""

    # Predict probability of the positive class (Good Quality, target=1)
    y_pred_proba = model.predict_proba(df_input)[:, 1]

    # Predict the final class (0 or 1)
    y_pred_class = (y_pred_proba >= 0.5).astype(int) # Using 0.5 threshold for simplicity

    return y_pred_class, y_pred_proba

# --- API Endpoints ---
@app.route('/ping', methods=['GET'])
def health_check():
    """Simple endpoint to verify the service is running."""
    return jsonify({'status': 'ok'})

@app.route('/predict', methods=['POST'])
def predict_endpoint():
    """
    Accepts a JSON payload (list of wine samples) and returns predictions.
    """
    # Get the input JSON data (which should be a list of dictionaries)
    wine_samples = request.get_json()

    # Then check if it is a single dict, and wrap in list if so
    if isinstance(wine_samples, dict):
        wine_samples = [wine_samples]

    # Prepare the input data
    df_input = prepare_input(wine_samples)

    # Generate predictions
    y_pred_class, y_pred_proba = predict(df_input)

    # Structure the response
    results = []

    for score, class_label in zip(y_pred_proba, y_pred_class):
        result = {
            'wine_quality_prediction': int(class_label),
            'probability_of_good_quality': round(float(score), 4)
        }
        results.append(result)

    return jsonify(results)

if __name__ == "__main__":
    # Flask typically runs on port 5000 locally
    # but we use a non-default port (8080) if required for Docker consistency later
    app.run(debug=True, host='0.0.0.0', port=5000)

